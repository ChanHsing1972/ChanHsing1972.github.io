---
title: ğŸ§‘ğŸ»â€ğŸ’» æ’åº
description: A brief introduction to different sorting algorithms. Mainly used for notes.
date: 2024-09-17 14:36:12 +0800
categories: [Schoolwork, Notes]
tags: [ç¨‹åº, ç®—æ³•, ä»£ç ]
math: true
---

## Procedure ğˆğ§ğ¬ğğ«ğ­ğ¢ğ¨ğ§-ğ’ğ¨ğ«ğ­

![pic-1](../assets/img/sort/insertion-sort.gif)

**In**: An array $A$ of $n$ integers.  
**Out**: A permutation of that array $A$ that is sorted (monotonic).

for $i := 2$ to $A.length$  
&emsp;&emsp;$key := A[i]$  
&emsp;&emsp;// Insert $A[i]$ into the sorted subarray $A[1 : i - 1]$  
&emsp;&emsp;$j := i - 1$  
&emsp;&emsp;while $j > 0$ and $A[j] > key$  
&emsp;&emsp;&emsp;&emsp;$A[j + 1] := A[j]$  
&emsp;&emsp;&emsp;&emsp;$j := j - 1$  
&emsp;&emsp;$A[j + 1] := key$  
&emsp;&emsp;return $A$  

---

One possible implementation with C++:

```c++
int main()
{
    int arr[100], len;
    cin >> len;
    for (int t = 0; t < len; t++)
      cin >> arr[t];
    for (int i = 1; i < len; i++)
    {
      int key = arr[i];               // æŠŠè¦æ¯”è¾ƒçš„ç‰Œä»æ‰‹ç‰Œé‡Œå•ç‹¬æŠ½å‡ºæ¥
      int j = i - 1;
      while (j > 0 && arr[j] > key)   // å°†æ­¤ç‰Œä¸å‰é¢çš„ç‰Œæ¯”è¾ƒå¤§å°
      {
        arr[j + 1] = arr[j];          // æŠŠå‰é¢çš„å¤§ç‰Œä¾æ¬¡å¾€åæŒªï¼Œç©ºå‡ºä½ç½®
        j--;
      }
      arr[j + 1] = key;               // æŠŠæ­¤ç‰Œæ’å…¥åˆé€‚çš„ä½ç½®
    }
    for (int t = 0; t < len; t++)
      cout << arr[t] << " ";
    return 0;
}
```

## Procedure ğŒğğ«ğ ğ-ğ’ğ¨ğ«ğ­

**In**: An array $A$ of $n$ integers.    
**Out**: A permutation of that array $A$ that is sorted (monotonic).  

**MergeSort**($A[1...n]$):  
if $n = 1$  
&emsp;&emsp;$sol[1...n] = [1...n]$  
else  
&emsp;&emsp;$solLeft[1...(n/2)] := MergeSort(A[1...(n/2)])$  
&emsp;&emsp;$solRight[1...(n/2)] := MergeSort(A[(n/2 + 1)...n])$  
&emsp;&emsp;$sol[1...n] := Merge(solLeft[1...(n/2)], solRight[1...(n/2)])$  
return $sol[1...n]$  

**Merge**($A[1...n], B[1...m]$):   
$Aindex := 1, Bindex := 1, Result := [ ]$  
// Scan $A$ and $B$ from left to right,   
// Append the currently smallest to the result array.  
while $Aindex \leq A.length$ and $Bindex \leq B.length$  
&emsp;&emsp;if $A[Aindex] \leq B[Aindex]$  
&emsp;&emsp;&emsp;&emsp;$Result.AddLast(A[Aindex])$  
&emsp;&emsp;&emsp;&emsp;$Aindex := Aindex + 1$  
&emsp;&emsp;else  
&emsp;&emsp;&emsp;&emsp;$Result.AddLast(B[Bindex])$  
&emsp;&emsp;&emsp;&emsp;$Bindex := Bindex + 1$  

// Copy the remaining elements of  A and B  
while $Aindex \leq A.length$  
&emsp;&emsp;$Result.AddLast(A[Aindex])$  
&emsp;&emsp;$Aindex := Aindex + 1$  
while $Bindex \leq B.length$  
&emsp;&emsp;$Result.AddLast(B[Bindex])$  
&emsp;&emsp;$Bindex := Bindex + 1$  
return $Result$  

---

One possible implementation with C++:  

```c++
void merge(int a[], int result[], int left, int mid, int right)
{
    int i = left, j = mid + 1, k = left;

    while (i <= mid && j <= right)
    {
    if (a[i] <= a[j])
        result[k++] = a[i++];
    else
        result[k++] = a[j++];
    }

    while (i <= mid)
        result[k++] = a[i++];
    while (j <= right)
        result[k++] = a[j++];

    for (i = left; i <= right; i++)
        a[i] = result[i];
}

void merge_sort(int a[], int result[], int left, int right)
{
    if (left < right)
    {
        int mid = (left + right) / 2;
        merge_sort(a, result, left, mid);
        merge_sort(a, result, mid + 1, right);
        merge(a, result, left, mid, right);
    }
}
```

## Procedure ğ‡ğğšğ©-ğ’ğ¨ğ«ğ­

One possible implementation with C++:  

```c++
#include <bits/stdc++.h>
using namespace std;

// è°ƒæ•´å †ï¼Œä¿æŒå †çš„æ€§è´¨
void heapify(int arr[], int n, int i) 
{
    int largest = i;    // é»˜è®¤æœ€å¤§å€¼ç´¢å¼•ä¸º i
    int left = 2 * i + 1;  // å·¦å­èŠ‚ç‚¹ç´¢å¼•
    int right = 2 * i + 2; // å³å­èŠ‚ç‚¹ç´¢å¼•

    // å¦‚æœå·¦å­èŠ‚ç‚¹å¤§äºæ ¹èŠ‚ç‚¹ï¼Œæ›´æ–°æœ€å¤§å€¼ç´¢å¼•
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // å¦‚æœå³å­èŠ‚ç‚¹å¤§äºæ ¹èŠ‚ç‚¹ï¼Œæ›´æ–°æœ€å¤§å€¼ç´¢å¼•
    if (right < n && arr[right] > arr[largest]) 
        largest = right;

    // å¦‚æœæœ€å¤§å€¼ç´¢å¼•ä¸ç­‰äº iï¼Œäº¤æ¢æ ¹èŠ‚ç‚¹ä¸æœ€å¤§å€¼èŠ‚ç‚¹ï¼Œå¹¶é€’å½’è°ƒæ•´å †
    if (largest != i) 
    {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

// å †æ’åº
void heapSort(int arr[], int n) 
{
    // æ„å»ºæœ€å¤§å †ï¼Œä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹è°ƒæ•´å †
    for (int i = n / 2 - 1; i >= 0; i--) 
        heapify(arr, n, i);

    // äº¤æ¢å †é¡¶å…ƒç´ ä¸å †çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¹¶é‡æ–°è°ƒæ•´å †
    for (int i = n - 1; i >= 0; i--) 
    {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```

## Procedure ğ’ğğ¥ğğœğ­ğ¢ğ¨ğ§-ğ’ğ¨ğ«ğ­

![pic-2](../assets/img/sort/selection-sort.gif)

**Basic idea**: pick out minimum element from input, then recursively sort 
remaining elements, and finally concatenate the minimum element with 
sorted remaining elements.

**In**: An array $A$ of $n$ integers.    
**Out**: A permutation of that array $A$ that is sorted (monotonic).  

**SelectionSort**($A$):  
for $i := 1$ to $A.length$  
&emsp;&emsp;$minIdx := i$  
&emsp;&emsp;for $j := i + 1$ to $A.length$   
&emsp;&emsp;&emsp;&emsp;if $A[j] < A[minIdx]$  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$minIdx := j$  
&emsp;&emsp;&emsp;&emsp;$Swap(i, minIdx)$

---

One possible implementation with C++:  

```c++
void SelectSort(int* arr, int n)
{
    // ä¿å­˜å‚ä¸å•è¶Ÿæ’åºçš„ç¬¬ä¸€ä¸ªæ•°å’Œæœ€åä¸€ä¸ªæ•°çš„ä¸‹æ ‡
    int begin = 0, end = n - 1;
    while (begin < end)
    {
        int max = begin; // ä¿å­˜æœ€å¤§å€¼çš„ä¸‹æ ‡
        int min = begin; // ä¿å­˜æœ€å°å€¼çš„ä¸‹æ ‡

        // æ‰¾å‡ºæœ€å¤§å€¼å’Œæœ€å°å€¼çš„ä¸‹æ ‡
        for (int i = begin; i <= end; ++i)
        {
            if (arr[i] < arr[min])
                min = i;
            if (arr[i] > arr[max])
                max = i;
        }

        // æœ€å°å€¼æ”¾åœ¨åºåˆ—å¼€å¤´
        swap(&arr[min], &arr[begin]); 

        // é˜²æ­¢æœ€å¤§çš„æ•°åœ¨ begin ä½ç½®è¢«æ¢èµ°
        if (begin == max)
            max = min;
            
        // æœ€å¤§å€¼æ”¾åœ¨åºåˆ—ç»“å°¾
        swap(&arr[max], &arr[end]); 

        ++begin;
        --end;
    }
}
```

## Procedure ğ’ğ¡ğğ¥ğ¥-ğ’ğ¨ğ«ğ­

![pic-3](../assets/img/sort/shell-sort.gif)

One possible implementation with C++:  

```c++
#include <bits/stdc++.h>
using namespace std;

void ShellSort(vector<int> &nums)
{
    int size = nums.size();
    for (int gap = size / 2; gap > 0; gap /= 2)
    {
        // ä½¿ç”¨æ’å…¥æ’åºå¯¹å½“å‰é—´éš”è¿›è¡Œæ’åº
        for (int i = gap; i < size; i++)
        {
            int key = nums[i];
            int j = i;
            while (j >= gap && nums[j - gap] > key)
            {
                nums[j] = nums[j - gap];
                j -= gap;
            }
            nums[j] = key;
        }
    }
}
```

## Procedure ğğ®ğ›ğ›ğ¥ğ-ğ’ğ¨ğ«ğ­

![pic-4](../assets/img/sort/bubble-sort.gif)

**Basic idea**: repeatedly step through the array, compare adjacent pairs and 
swaps them if they are in the wrong order. Thus, larger elements "bubble" to 
the â€œtopâ€.

**In**: An array $A$ of $n$ integers.    
**Out**: A permutation of that array $A$ that is sorted (monotonic).  

**BubbleSort**($A$):  
for $i := A.length$ down to $2$  
&emsp;&emsp;for $j := 1$ to $i - 1$  
&emsp;&emsp;&emsp;&emsp;if $A[j] > A[j+1]$  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$Swap(A[j], A[j+1])$

---

One possible implementation with C++:  

```c++
void BubbleSort(int* arr, int n)
{
    int end = n;
    while (end)
    {
        int flag = 0;
        for (int i = 1; i < end; ++i)
        {
            if (arr[i - 1] > arr[i])
            {
                int tem = arr[i];
                arr[i] = arr[i - 1];
                arr[i - 1] = tem;
                flag = 1;
            }
        }
        if (flag == 0)
            break;
        --end;
    }
}
```

## Procedure ğğ®ğ¢ğœğ¤-ğ’ğ¨ğ«ğ­

![pic-5](../assets/img/sort/quick-sort.gif)

**Basic idea**: Given an array $A$ of $n$ items.
- Choose one item $x$ in $A$ as the pivot.
- Use the pivot to partition the input into $B$ and $C$, so that items in $B$ are $\leq x$, and items in $C$ are $> x$.
- Recursively sort $B$ and $C$.
- Output $âŸ¨B, x, CâŸ©$.

**In**: An array $A$ of $n$ integers.    
**Out**: A permutation of that array $A$ that is sorted (monotonic).  

**QuickSortAbs**($A$):  
$x := GetPivot(A)$  
$<B, C> := Partition(A, x)$  
$QuickSortAbs(B)$  
$QuickSortAbs(C)$  
return $Concatenate(B, x, C)$  

---

One possible implementation with C++:  

```c++
#include <bits/stdc++.h>
using namespace std;

// é€‰å®šä¸€ä¸ªpivotå¹¶å°†leftåˆ°rightä¹‹é—´çš„å…ƒç´ é€šè¿‡pivotåˆ’åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œç„¶åè¿”å›pivotçš„ä¸‹æ ‡
int _partition(vector<int> &nums, int left, int right)
{
    int pivot = nums[left];
    while (left < right)
    {
        while (left < right && nums[right] >= pivot)
            right--;
        nums[left] = nums[right];
        while (left < right && nums[left] <= pivot)
            left++;
        nums[right] = nums[left];
    }
    nums[left] = pivot;
    return left;
}

// å°†numsé€šè¿‡_partitionåˆ’åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå¯¹æ¯ä¸ªéƒ¨åˆ†è°ƒç”¨_quick_sort
void _quick_sort(vector<int> &nums, int left, int right)
{
    if (left < right)
    {
        int p = _partition(nums, left, right);
        _quick_sort(nums, left, p - 1);
        _quick_sort(nums, p + 1, right);
    }
}

void QuickSort(vector<int> &nums)
{
    _quick_sort(nums, 0, nums.size() - 1);
}
```

## **Summary**

| Algorithms | Best | Worst | Average | In/Out-Place | Stability |
| :--------: | :--: | :---: | :-----: | :----------: | :-------: |
| Insertion-Sort | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | In-place | True |
| Merge-Sort | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | Out-place | True |
| Heap-Sort | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | In-place | False |
| Selection-Sort | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | In-place | False |
| Shell-Sort | $O(n\log{n})$ | $O(n^2)$ | - | In-place | False |
| Bubble-Sort | $O(n)$ | $O(n^2)$ | $O(n^2)$ | In-place | True |
| Quick-Sort | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | In-place | False |