---
title: ğŸ§‘ğŸ»â€ğŸ’» æ’åº
description: è®°å½•äº† C++ ä¸­å‡ ç§æ’åºæ–¹æ³•çš„å®ç°ã€‚ä½œç¬”è®°ç”¨ã€‚
date: 2024-09-17 14:36:12 +0800
categories: [Schoolwork, Notes]
tags: [ç¨‹åº, ç®—æ³•, ä»£ç ]
math: true
---

Characteristics of sorting algorithms:

- In-place: a sorting algorithm is in-place if $O(1)$ extra space is needed beyond input. 

- Stability: a sorting algorithm is stable if numbers with the same value appear in the output array in the same order as they do in the input array.

## Procedure ğˆğ§ğ¬ğğ«ğ­ğ¢ğ¨ğ§-ğ’ğ¨ğ«ğ­[^footnote]

![pic-1](../assets/img/sort/insertion-sort.gif)

**In**: An array $A$ of $n$ integers.  
**Out**: A permutation of that array $A$ that is sorted (monotonic).

for $i := 2$ to $A.length$  
&emsp;&emsp;$key := A[i]$  
&emsp;&emsp;// Insert $A[i]$ into the sorted subarray $A[1 : i - 1]$  
&emsp;&emsp;$j := i - 1$  
&emsp;&emsp;while $j > 0$ and $A[j] > key$  
&emsp;&emsp;&emsp;&emsp;$A[j + 1] := A[j]$  
&emsp;&emsp;&emsp;&emsp;$j := j - 1$  
&emsp;&emsp;$A[j + 1] := key$  
&emsp;&emsp;return $A$  

---

One possible implementation with C++:

```c++
int main()
{
    int arr[100], len;
    cin >> len;
    for (int t = 0; t < len; t++)
      cin >> arr[t];
    for (int i = 1; i < len; i++)
    {
      int key = arr[i];               // æŠŠè¦æ¯”è¾ƒçš„ç‰Œä»æ‰‹ç‰Œé‡Œå•ç‹¬æŠ½å‡ºæ¥
      int j = i - 1;
      while (j > 0 && arr[j] > key)   // å°†æ­¤ç‰Œä¸å‰é¢çš„ç‰Œæ¯”è¾ƒå¤§å°
      {
        arr[j + 1] = arr[j];          // æŠŠå‰é¢çš„å¤§ç‰Œä¾æ¬¡å¾€åæŒªï¼Œç©ºå‡ºä½ç½®
        j--;
      }
      arr[j + 1] = key;               // æŠŠæ­¤ç‰Œæ’å…¥åˆé€‚çš„ä½ç½®
    }
    for (int t = 0; t < len; t++)
      cout << arr[t] << " ";
    return 0;
}
```

## Procedure ğŒğğ«ğ ğ-ğ’ğ¨ğ«ğ­

**In**: An array $A$ of $n$ integers.    
**Out**: A permutation of that array $A$ that is sorted (monotonic).  

**MergeSort**($A[1...n]$):  
if $n = 1$  
&emsp;&emsp;$sol[1...n] = [1...n]$  
else  
&emsp;&emsp;$solLeft[1...(n/2)] := MergeSort(A[1...(n/2)])$  
&emsp;&emsp;$solRight[1...(n/2)] := MergeSort(A[(n/2 + 1)...n])$  
&emsp;&emsp;$sol[1...n] := Merge(solLeft[1...(n/2)], solRight[1...(n/2)])$  
return $sol[1...n]$  

**Merge**($A[1...n], B[1...m]$):   
$Aindex := 1, Bindex := 1, Result := [ ]$  
// Scan $A$ and $B$ from left to right,   
// Append the currently smallest to the result array.  
while $Aindex \leq A.length$ and $Bindex \leq B.length$  
&emsp;&emsp;if $A[Aindex] \leq B[Aindex]$  
&emsp;&emsp;&emsp;&emsp;$Result.AddLast(A[Aindex])$  
&emsp;&emsp;&emsp;&emsp;$Aindex := Aindex + 1$  
&emsp;&emsp;else  
&emsp;&emsp;&emsp;&emsp;$Result.AddLast(B[Bindex])$  
&emsp;&emsp;&emsp;&emsp;$Bindex := Bindex + 1$  

// Copy the remaining elements of  A and B  
while $Aindex \leq A.length$  
&emsp;&emsp;$Result.AddLast(A[Aindex])$  
&emsp;&emsp;$Aindex := Aindex + 1$  
while $Bindex \leq B.length$  
&emsp;&emsp;$Result.AddLast(B[Bindex])$  
&emsp;&emsp;$Bindex := Bindex + 1$  
return $Result$  

---

One possible implementation with C++:  

```c++
void merge(int a[], int result[], int left, int mid, int right)
{
    int i = left, j = mid + 1, k = left;

    // æŒ‰å¤§å°é¡ºåºä¾æ¬¡æ·»åŠ åˆ° result æ•°ç»„ä¸­
    while (i <= mid && j <= right)
    {
    if (a[i] <= a[j])
        result[k++] = a[i++];
    else
        result[k++] = a[j++];
    }

    // å¤„ç†å‰©ä½™çš„æ•°
    while (i <= mid)
        result[k++] = a[i++];
    while (j <= right)
        result[k++] = a[j++];

    for (i = left; i <= right; i++)
        a[i] = result[i];
}

void merge_sort(int a[], int result[], int left, int right)
{
    if (left < right)
    {
        int mid = (left + right) / 2;
        merge_sort(a, result, left, mid);
        merge_sort(a, result, mid + 1, right);
        merge(a, result, left, mid, right);
    }
}
```

## Procedure ğ‡ğğšğ©-ğ’ğ¨ğ«ğ­

1. Keep a copy of the root item
2. Remove last item and put it to root
3. Maintain heap property
4. Return the copy of the root item

One possible implementation with C++:  

```c++
#include <bits/stdc++.h>
using namespace std;

// maintain heap property
void heapify(int arr[], int n, int i) 
{
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int largest = i;

    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest]) 
        largest = right;
    if (largest != i) 
    {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) 
{
    // build max heap   
    for (int i = n / 2 - 1; i >= 0; i--) 
        heapify(arr, n, i);

    // swap the root item with the last item,
    // then heapify the remaining items
    for (int i = n - 1; i >= 0; i--) 
    {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```

## Procedure ğ’ğğ¥ğğœğ­ğ¢ğ¨ğ§-ğ’ğ¨ğ«ğ­

![pic-2](../assets/img/sort/selection-sort.gif)

**Basic idea**: pick out minimum element from input, then recursively sort 
remaining elements, and finally concatenate the minimum element with 
sorted remaining elements.

**In**: An array $A$ of $n$ integers.    
**Out**: A permutation of that array $A$ that is sorted (monotonic).  

**SelectionSort**($A$):  
for $i := 1$ to $A.length$  
&emsp;&emsp;$minIdx := i$  
&emsp;&emsp;for $j := i + 1$ to $A.length$   
&emsp;&emsp;&emsp;&emsp;if $A[j] < A[minIdx]$  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$minIdx := j$  
&emsp;&emsp;&emsp;&emsp;$Swap(i, minIdx)$

---

One possible implementation with C++:  

```c++
void SelectSort(int* arr, int n)
{
    // ä¿å­˜å‚ä¸å•è¶Ÿæ’åºçš„ç¬¬ä¸€ä¸ªæ•°å’Œæœ€åä¸€ä¸ªæ•°çš„ä¸‹æ ‡
    int begin = 0, end = n - 1;
    while (begin < end)
    {
        int maxIndex = begin; // ä¿å­˜æœ€å¤§å€¼çš„ä¸‹æ ‡
        int minIndex = begin; // ä¿å­˜æœ€å°å€¼çš„ä¸‹æ ‡

        // æ‰¾å‡ºæœ€å¤§å€¼å’Œæœ€å°å€¼å¯¹åº”çš„ä¸‹æ ‡
        for (int i = begin; i <= end; ++i)
        {
            if (arr[i] < arr[minIndex])
                minIndex = i;
            if (arr[i] > arr[maxIndex])
                maxIndex = i;
        }

        // æœ€å°å€¼æ”¾åœ¨åºåˆ—å¼€å¤´
        swap(&arr[minIndex], &arr[begin]); 

        // å¦‚æœæœ€å¤§å€¼åŸæœ¬åœ¨ begin ä½ç½®ï¼Œå³ maxIndex == beginï¼Œ
        // é‚£ä¹ˆä¸Šé¢çš„æ“ä½œä¼šå°†æœ€å¤§å€¼æ¢åˆ°ä¸‹æ ‡ä¸º minIndex å¤„ï¼Œ
        // æ­¤æ—¶ maxIndex ä¸å†æ˜¯æœ€å¤§å€¼çš„ä¸‹æ ‡ï¼Œè€Œæ˜¯æœ€å°å€¼çš„ã€‚
        // ä¸ºäº†é˜²æ­¢ä»¥ä¸Šæƒ…å†µå‘ç”Ÿï¼Œæˆ‘ä»¬éœ€è¦æ›´æ–°ä¸€ä¸‹ maxIndexã€‚
        if (begin == maxIndex)
            maxIndex = minIndex;
        
        // æœ€å¤§å€¼æ”¾åœ¨åºåˆ—ç»“å°¾
        swap(&arr[maxIndex], &arr[end]); 

        ++begin;
        --end;
    }
}
```

## Procedure ğ’ğ¡ğğ¥ğ¥-ğ’ğ¨ğ«ğ­

![pic-3](../assets/img/sort/shell-sort.gif)

One possible implementation with C++:  

```c++
#include <bits/stdc++.h>
using namespace std;

void ShellSort(vector<int> &nums)
{
    int size = nums.size();
    for (int gap = size / 2; gap > 0; gap /= 2)
    {
        // ä½¿ç”¨æ’å…¥æ’åºå¯¹å½“å‰é—´éš”è¿›è¡Œæ’åº
        for (int i = gap; i < size; i++)
        {
            int key = nums[i];
            int j = i;
            while (j >= gap && nums[j - gap] > key)
            {
                nums[j] = nums[j - gap];
                j -= gap;
            }
            nums[j] = key;
        }
    }
}
```

## Procedure ğğ®ğ›ğ›ğ¥ğ-ğ’ğ¨ğ«ğ­

![pic-4](../assets/img/sort/bubble-sort.gif)

**Basic idea**: repeatedly step through the array, compare adjacent pairs and 
swaps them if they are in the wrong order. Thus, larger elements "bubble" to 
the â€œtopâ€.

**In**: An array $A$ of $n$ integers.    
**Out**: A permutation of that array $A$ that is sorted (monotonic).  

**BubbleSort**($A$):  
for $i := A.length$ down to $2$  
&emsp;&emsp;for $j := 1$ to $i - 1$  
&emsp;&emsp;&emsp;&emsp;if $A[j] > A[j + 1]$  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$Swap(A[j], A[j + 1])$

---

One possible implementation with C++:  

```c++
void BubbleSort(int arr[], int len) 
{
        int i, j;
        for (i = 0; i < len - 1; i++)
        {
            for (j = 0; j < len - 1 - i; j++)
            {
                if (arr[j] > arr[j + 1])
                {
                    swap(arr[j], arr[j + 1]);
                }
            }
        }
}
```

## Procedure ğğ®ğ¢ğœğ¤-ğ’ğ¨ğ«ğ­

![pic-5](../assets/img/sort/quick-sort.gif)

**Basic idea**: Given an array $A$ of $n$ items.
- Choose one item $x$ in $A$ as the pivot.
- Use the pivot to partition the input into $B$ and $C$, so that items in $B$ are $\leq x$, and items in $C$ are $> x$.
- Recursively sort $B$ and $C$.
- Output $âŸ¨B, x, CâŸ©$.

**In**: An array $A$ of $n$ integers.    
**Out**: A permutation of that array $A$ that is sorted (monotonic).  

**QuickSortAbs**($A$):  
$x := GetPivot(A)$  
$<B, C> := Partition(A, x)$  
$QuickSortAbs(B)$  
$QuickSortAbs(C)$  
return $Concatenate(B, x, C)$  

---

One possible implementation with C++:  

```c++
#include <bits/stdc++.h>
using namespace std;

// é€‰å®šä¸€ä¸ª pivot å¹¶å°† left åˆ° right ä¹‹é—´çš„å…ƒç´ é€šè¿‡ pivot åˆ’åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œ
// ä½¿å¾— pivot å·¦è¾¹çš„å…ƒç´ éƒ½å°äºå®ƒï¼Œå³è¾¹çš„å…ƒç´ éƒ½å¤§äºå®ƒï¼Œç„¶åè¿”å› pivot çš„ä¸‹æ ‡
int _partition(vector<int> &nums, int left, int right)
{
  int pivot = nums[left]; // ä»¤ pivot ä¸ºå·¦è¾¹ç¬¬ä¸€ä¸ªå…ƒç´ 
  while (left < right)
  {
    // å¦‚æœå³è¾¹å…ƒç´ å¤§äº pivotï¼Œä¸ç®¡ï¼›åä¹‹ï¼Œåˆ™è®©å®ƒåˆ°å·¦è¾¹å»
    while (left < right && nums[right] >= pivot)
      right--;
    nums[left] = nums[right];
    // å¦‚æœå·¦è¾¹å…ƒç´ å°äº pivotï¼Œä¸ç®¡ï¼›åä¹‹ï¼Œåˆ™è®©å®ƒåˆ°å³è¾¹å»
    while (left < right && nums[left] <= pivot)
      left++;
    nums[right] = nums[left];
  }
  nums[left] = pivot; // æœ€åè®°å¾—æ¢å¤ pivotï¼ï¼ï¼
  return left;
}

// å°† nums é€šè¿‡ _partition åˆ’åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå¯¹æ¯ä¸ªéƒ¨åˆ†è°ƒç”¨ _quick_sort
void _quick_sort(vector<int> &nums, int left, int right)
{
  if (left < right)
  {
    int p = _partition(nums, left, right);
    _quick_sort(nums, left, p - 1);
    _quick_sort(nums, p + 1, right);
  }
}

void QuickSort(vector<int> &nums)
{
  _quick_sort(nums, 0, nums.size() - 1);
}
```

## Procedure ğğ®ğœğ¤ğğ­-ğ’ğ¨ğ«ğ­

1. Create $d$ empty lists. (These are the **buckets**.)
2. Scan through input, for each item, append it to the end of the corresponding list.
3. Concatenate all lists.

This algorithm only takes $\Theta(n)$ time.
- This is not a comparison based algorithm.
- No comparison between items are made.
- Instead the algorithm uses actual values of the items.

```cpp
void bucketSort(vector<int> &nums) 
{
    int n = nums.size();
    int mn = nums[0], mx = nums[0];
    for (int i = 1; i < n; i++) 
    {
        mn = min(mn, nums[i]);
        mx = max(mx, nums[i]);
    }
    int size = (mx - mn) / n + 1;   // size è‡³å°‘è¦ä¸º1
    int cnt = (mx - mn) / size + 1; // æ¡¶çš„ä¸ªæ•°è‡³å°‘è¦ä¸º1
    vector<vector<int>> buckets(cnt);
    for (int i = 0; i < n; i++) 
    {
        int idx = (nums[i] - mn) / size;
        buckets[idx].push_back(nums[i]);
    }
    for (int i = 0; i < cnt; i++) 
    {
        sort(buckets[i].begin(), buckets[i].end());
    }
    int index = 0;
    for (int i = 0; i < cnt; i++) 
    {
        for (int j = 0; j < buckets[i].size(); j++) 
        {
            nums[index++] = buckets[i][j];
        }
    }
}
```

## Procedure ğ‘ğšğğ¢ğ±-ğ’ğ¨ğ«ğ­

![pic](../assets/img/sort/radix-sort.gif)

```cpp
int maxbit(int data[], int n) // è¾…åŠ©å‡½æ•°ï¼Œæ±‚æ•°æ®çš„æœ€å¤§ä½æ•°
{
    int maxData = data[0]; // æœ€å¤§æ•°
    // å…ˆæ±‚å‡ºæœ€å¤§æ•°ï¼Œå†æ±‚å…¶ä½æ•°ï¼Œè¿™æ ·æœ‰åŸå…ˆä¾æ¬¡æ¯ä¸ªæ•°åˆ¤æ–­å…¶ä½æ•°ï¼Œç¨å¾®ä¼˜åŒ–ç‚¹ã€‚
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        maxData /= 10;
        ++d;
    }
    return d;
}

void radixsort(int data[], int n) // åŸºæ•°æ’åº
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; // è®¡æ•°å™¨
    int i, j, k;
    int radix = 1;
    for (i = 1; i <= d; i++) // è¿›è¡Œ d æ¬¡æ’åº
    {
        for (j = 0; j < 10; j++)
            count[j] = 0; // æ¯æ¬¡åˆ†é…å‰æ¸…ç©ºè®¡æ•°å™¨
        for (j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; // ç»Ÿè®¡æ¯ä¸ªæ¡¶ä¸­çš„è®°å½•æ•°
            count[k]++;
        }
        for (j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; // å°† tmp ä¸­çš„ä½ç½®ä¾æ¬¡åˆ†é…ç»™æ¯ä¸ªæ¡¶
        for (j = n - 1; j >= 0; j--)            // å°†æ‰€æœ‰æ¡¶ä¸­è®°å½•ä¾æ¬¡æ”¶é›†åˆ° tmp ä¸­
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for (j = 0; j < n; j++) // å°†ä¸´æ—¶æ•°ç»„çš„å†…å®¹å¤åˆ¶åˆ° data ä¸­
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete[] tmp;
    delete[] count;
}
```

## **Summary**

| Algorithms | Best | Worst | Average | In/Out-Place | Stability |
| :--------: | :--: | :---: | :-----: | :----------: | :-------: |
| Insertion-Sort | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | In-place | True |
| Merge-Sort | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | Out-place | True |
| Heap-Sort | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | In-place | False |
| Selection-Sort | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | In-place | False |
| Shell-Sort | $O(n\log{n})$ | $O(n^2)$ | - | In-place | False |
| Bubble-Sort | $O(n)$ | $O(n^2)$ | $O(n^2)$ | In-place | True |
| Quick-Sort | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | In-place | False |
| Bucket-Sort | $O(n + k)$ | $O(n^2)$ | $O(n + k)$ | Out-place | True |
| Radix-Sort | $O(n \cdot k)$ | $O(n \cdot k)$ | $O(n \cdot k)$ | Out-place | True |

[^footnote]: All the images in this article are derived from [this blog](https://blog.csdn.net/xuxianshun666/article/details/138798595).