---
title: ğŸ§‘ğŸ»â€ğŸ’» å †ï¼ˆå°æ ¹å †ï¼‰
description: åœ¨ C++ ä¸­ï¼Œä½¿ç”¨æ•°ç»„å®ç°å°æ ¹å †åŠå…¶ç›¸å…³æ“ä½œçš„æ€è·¯å’Œä»£ç ã€‚ä½œç¬”è®°ç”¨ã€‚
date: 2024-10-29 19:25:16 +0800
categories: [Schoolwork, Notes]
tags: [ç¨‹åº, ç®—æ³•, ä»£ç ]
math: true
image:
  path: ../assets/img/heap.png
---

å°æ ¹å †æ˜¯ä¸€ç§äºŒå‰å †æ•°æ®ç»“æ„ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å°äºæˆ–ç­‰äºå…¶å­èŠ‚ç‚¹çš„å€¼ã€‚ä»¥ä¸‹æ˜¯å®ç°ä¸€ä¸ªå°æ ¹å †çš„ C++ ä»£ç ï¼Œä¸€å…±æ”¯æŒå…­ç§æ“ä½œã€‚

- `push(x)`ï¼šå°†å…ƒç´  $x$ æ’å…¥å †ä¸­ã€‚
- `pop()`ï¼šåˆ é™¤å †ä¸­çš„æœ€å°å…ƒç´ ã€‚
- `top()`ï¼šè¿”å›å †ä¸­çš„æœ€å°å…ƒç´ ï¼Œä½†ä¸åˆ é™¤å®ƒã€‚
- `size()`ï¼šè¿”å›å †ä¸­å…ƒç´ çš„æ•°é‡ã€‚
- `decrease(i, k)`ï¼šå°†ç¬¬ $i$ æ¬¡ `push` æ“ä½œï¼ˆå…¶ä»–ç±»å‹æ“ä½œä¸å‚ä¸ç¼–å·ï¼‰æ’å…¥çš„å…ƒç´ å‡å°‘ä¸º $k$ï¼Œä¿è¯ $k$ å°äºåŸå€¼ã€‚
- `print`ï¼šæ‰“å°å †ã€‚

```c++
#include <bits/stdc++.h>
using namespace std;

class minHeap
{
private:
  vector<int> vec;             // items in the heap
  vector<int> order;           // order of insertion
  int insert_index = 0;

public:
  void push(int x);            // push x into the heap
  void pop();                  // remove the minimum item from the heap
  int top();                   // return the minimum item of the heap
  int size();                  // return number of items in the heap
  void decrease(int i, int k); // reduce the ith-inserted item to k
  void print();                // print the heap
};

void minHeap::push(int x)
{
  // simply put the item to the end of the array
  vec.push_back(x);
  order.push_back(insert_index++);

  // maintain heap property after insertion:
  // along the path to root, compare and swap
  int index = vec.size() - 1;
  while (index > 0 && vec.at(index) < vec.at((index - 1) / 2))
  {
    swap(vec.at(index), vec.at((index - 1) / 2));
    swap(order.at(index), order.at((index - 1) / 2));
    index = (index - 1) / 2;
  }
  return;
}

void minHeap::pop()
{
  if (vec.size() == 1)
  {
    vec.pop_back();
    order.pop_back();
    return;
  }

  // remove the minimum item (root) from the heap,
  // and move the last item to the root
  vec.at(0) = vec.at(vec.size() - 1);
  order.at(0) = order.at(order.size() - 1);
  vec.pop_back();
  order.pop_back();

  int index = 0;
  while (index < vec.size())
  {
    int l_index = 2 * index + 1;
    int r_index = 2 * index + 2;
    int min_index = index;

    // compare with children, swap with the smaller one
    if (l_index < vec.size() && vec.at(l_index) < vec.at(min_index))
      min_index = l_index;
    if (r_index < vec.size() && vec.at(r_index) < vec.at(min_index))
      min_index = r_index;
    if (min_index != index)
    {
      swap(vec.at(index), vec.at(min_index));
      swap(order.at(index), order.at(min_index));
      index = min_index;
    }
    else
      break;
  }
}

int minHeap::top() { return vec.at(0); }

int minHeap::size() { return vec.size(); }

void minHeap::decrease(int i, int k)
{
  // find the ith insertion, reduce it to k
  int i_index = 0;
  for (i_index; i_index < order.size(); i_index++)
  {
    if (order.at(i_index) == i)
      break;
  }
  vec.at(i_index) = k;

  // maintain min-heap property
  while (i_index > 0 && vec[i_index] < vec[(i_index - 1) / 2])
  {
    swap(vec[i_index], vec[(i_index - 1) / 2]);
    swap(order[i_index], order[(i_index - 1) / 2]);
    i_index = (i_index - 1) / 2;
  }
}

void minHeap::print()
{
  for (int i = 0; i < vec.size(); i++)
    cout << vec[i] << " ";
  cout << endl;
}
```